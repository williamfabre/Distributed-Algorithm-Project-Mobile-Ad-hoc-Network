\documentclass[11pt,a4paper,sans]{report}
\input{header.sty}

\begin{document}
\begin{titlepage}

	\center % Center everything on the page

	%----------------------------------------------------------------------------------------
	%	HEADING SECTIONS
	%----------------------------------------------------------------------------------------

	\textsc{\LARGE Université Pierre et Marie Curie}\\[1.5cm] % Name of your university/college
	\textsc{\Large projet MANET}\\[0.5cm] % Major heading such as course name

	%----------------------------------------------------------------------------------------
	%	TITLE SECTION
	%----------------------------------------------------------------------------------------
	\vfill
	\HRule \\[0.4cm]
	{ \huge \bfseries Compte-rendu : Projet ARA 2019–2020, Mobile Ad hoc NETworks }\\[0.4cm] 
	\HRule \\[1.5cm]
	\vfill
	%----------------------------------------------------------------------------------------
	%	AUTHOR SECTION
	%----------------------------------------------------------------------------------------

	\begin{minipage}{0.4\textwidth}
		\begin{flushleft} \large
			\emph{Auteurs:}\\
			% Ordre alphabetique sur les noms
			\textsc{Maria Popova, William Fabre} 
		\end{flushleft}
	\end{minipage}
	~
	\begin{minipage}{0.4\textwidth}
		\begin{flushright} \large
			\emph{Professeur:} \\
			Monsieur \textsc{Lejeune},\textsc{Favier}
		\end{flushright}
	\end{minipage}\\[2cm]

	%----------------------------------------------------------------------------------------
	%	DATE SECTION
	%----------------------------------------------------------------------------------------

	{\large Année 2019-2020}\\[2cm] % Date, change the \today to a set date if you want to be precise

\end{titlepage}

\newpage
\tableofcontents
\vspace*{3cm}
\begingroup\let\clearpage\relax

	\newpage
	\chapter{Introduction}

	%multilinecomments
	\begin{comment}
		TODO intro du projet, nos remarques. + Explication du fichier de config accompagnées d’un fichier texte "Readme"
		indiquant comment compiler le projet et lancer les différentes simulations (votre projet doit pouvoir se compiler/lancer en dehors d’Eclipse) Votre rapport, au format pdf, concis, dans lequel vous devez répondre aux questions posées dans le sujet.
	\end{comment}

	% TODO quotation work use the biblio.bib to add references.
	TODOCHANGEHEREtest1234\cite{greenwade93}

	\newpage
	\chapter{Préparation du projet et installation}
	% TODO tutoriel d'installation
	\newpage
	\chapter{Exercice 1 – Implémentation d’un MANET dans Peer-Sim}

	\section{Question 1}
	\textit{En analysant le code de la classe PositionProtocolImpl, donnez l’algorithme général de déplacement d’un nœud. Il ne vous est pas demandé de copier/coller le code dans cette question.}
	\par Le but de cet algorithme est de deplacer un noeud dans l'espace de deux dimenssions en direction d'une position choisi en fonction de la strategie de deplacement.  L'algorithme de deplacement du noeud fonctionne comme suit :
	\par Si le noeud ne bouge pas alors il est mis en mouvement. C'est a dire q'on lui affecte une vitesse \texttt{vi} aleatoire bornee par un \texttt{MinSpeed} et un \texttt{MaxSpeed}. Puis on lui choisi une desination qui est de type Position (element qui possede deux coordonnes). Il faut maintenant calculer la distance en metres entre le point de depart, qui est la position du Node et la position d'arrivee, que nous appellerons destination ; Grace a la formule suivante :
	\begin{gather}
		Soit \quad  (dest, cur) \in Position^2, \\
		distance = (dest.x - cur.x)^2 + (dest.y - cur.y)^2 
	\end{gather}
	\par C'est la distance total pour arriver a destination. Maintenant il nous faut calculer la distance totale parcourable en une unite de temps. Elle est egale a la vitesse dans la metrique du systeme, c'est a dire, la vitesse \texttt{vi} en metres par secondes qu'il faut diviser par mille pour avoir des metre par millisecondes.
	\begin{gather}
		Soit  \quad  (vi) \in Vitesse \quad (m*s^{-1}), \\
		distance\_to\_next= vi / 1000
	\end{gather}
	\par Si la distance totale est inferieur a la distance parcourable en une unite de temps il faut alors calculer une nouvelle Position intermediaire et donc un x et un y:

	\begin{gather}
		Soit  \quad  (next_x,next_y) \in long^2 \\
		Soit  \quad  (\theta_{1}, \theta_{2}) \in degree^2 \\
		next\_x =  (distance\_to\_next * \dfrac{(dest.x - cur.x)}{((dest.x - cur.x)^2 + (dest.y - cur.y)^2)}) + cur.x \\
		\Longleftrightarrow \\
		next\_x =  (distance\_to\_next * \sin{\theta_{1}}) + cur.x \\
		\\
		\\
		next\_y =  (distance\_to\_next * \dfrac{(dest.y - cur.y)}{((dest.x - cur.x)^2 + (dest.y - cur.y)^2)}) + cur.y \\
		\Longleftrightarrow \\
		next\_y =  (distance\_to\_next * \cos(\theta_{2})) + cur.x \\
	\end{gather}

	Sinon, si la distance total est egale ou inferieur a la distance parcourable en une unite de temps, alors on affete les coordonnes de la position destination a notre Node.

	% TODO expliquer mieux.
	On vient verifier si la position a change, pour affecter une pause, sinon on incremente le temps du simulateur d'une unite de temps.

	\section{Question 2}
	\textit{Testez le simulateur en prenant la stratégie FullRandom comme SPI et SD. Le contrôleur graphique sera déclenché toutes les unités de temps, son timeslow pourra être environ de 0.0002. Le seul protocole à renseigner pour ce contrôleur est le PositionProtocol de la simulation, les autres sont pour l’instant optionnels et sans objet.  Normalement vous devez voir graphiquement des points verts se déplacer sur l’écran.  N’oubliez pas d’amorcer les instances de PositionProtocol via un module d’initialisation. Vous répondrez à cette question en donnant le contenu de votre fichier de configuration.}
	% TODO inserer le fichier de configuration necessiare pour faire cette question
	\mylisting[basicstyle=\tiny,frame=rlbt,language=Java]{../src/ara/config} %with frame

	\section{Question 3}
	\textit{Codez une classe implémentant l’interface Emitter. Testez de nouveau avec le moniteur graphique et assurez-vous que les portées sont représentées (cercle en bleu).  Vous répondrez à cette question en donnant le code de votre classe.}
	% TODO inserer le code de la classe qui implemente Emitter
	\mylisting[basicstyle=\tiny,frame=rlbt,language=Java]{../src/ara/manet/communication/EmitterProtocolImpl.java}
	%\lstinputlisting[language=Java]{\communication}


	\section{Question 4}
	% Peut etre expliquer les difficultes?

	\section{Question 5}
	\par\textit{Testez votre code, et remarquez sur le moniteur graphique l’apparition d’un lien graphique lorsque deux nœuds deviennent voisins.}
	\begin{figure}[h]
		\centering
		\includegraphics[width=\textwidth, frame]{question5_links}
		\caption{Representation de l'apparition de lien lors de la simulation}
		\label{fig:mesh1}
	\end{figure}


	% TODO ecrire un commentaire intelligible ici on peut voir comment referencer une figure
	% on peut aussi comment referencer directement la page d'une figure
	\par As you can see in the figure \ref{fig:mesh1}, the 
	function grows near 0. Also, in the page \pageref{fig:mesh1} 
	is the same example.

	\section{Question 6}
	\textit{En analysant les codes des classes gérant le positionnement des nœuds qui font appel à un tirage aléatoire, on peut remarquer qu’ils utilisent un objet Random qui leur est dédié (attribut my\_random initialisé au random de la classe PositioningConfiguration).  Quelle en est la raison ?}

	\begin{comment}
		il faut finir l'analyse du code commence dans mon carnet mais je pense actuellement que c'est pour etre sur d'avoir bien deux random differents, en effet on applique le meme calcule a deux entitees et on obtient donc un random pour x et un pour y qui sont egaux. Avec deux randoms, on a x != y.
	\end{comment}

	\section{Question 7}
	\textit{Prenez connaissance des différentes stratégies et pour chacune expliquez ce qu’elle fait.}
	Pour chacune les strategies de placement de noeuds dans l'espace il existe deux types de placement : Un placement dit initial et un deplacement qui sont represente par deux fonctions :
	\texttt{getInitialPosition} et \texttt{getNextDestination}. Les strategies implementent ces fonctions si elles implementent leur interfaces : \texttt{InitialPositionStrategy} et \texttt{NextDestinationStrategy} ceci sera precise dans le titre des sections suivantes.

	\subsection*{Strategie 1 : ConnectedRandom (InitialPositionStrategy, NextDestinationStrategy)}

	\begin{figure}[H]
		\centering
		\includegraphics[width=\textwidth, frame]{StrategieConnectedRandom}
		\caption{Representation du calcule pour le placement connected Random}
		\label{fig:mesh1}
	\end{figure}


	\par Les elements de la figure \ref{fig:mesh1} sont :
	\begin{itemize}
		\item A gauche, la grille de placement des noeuds avec \texttt{max\_X} et \texttt{max\_Y} qui sont des parametres du systeme. On peut aussi voir \texttt{max\_X / 2} et \texttt{max\_Y / 2}. Pour finir, \texttt{maxX, maxY, minX, minY} correspondent aux nouveaux min et max calcules par la fonction en additionnant ou soustrayant delta visible graphiquement. La zone hachuree correspond a l'ensemble des coordonnees possible pour une position randomizee.
		\item A droite, On peut observer le scope d'un noeud et un parametre de marge de l'algorithme Connected Random.
		\item En bas on peut observer graphiquement la taille de \textt{scope-marge}
	\end{itemize}

	La figure ci dessus\pageref{fig:mesh1} represente l'implementation pour les fonctions \texttt{getInitialPosition} et \texttt{getNextDestination}, il existe un argument de fonction speed qui n'est pas utilise malgre le fait que l'interface \texttt{NextDestinationStrategy} explique :
	\par "Retourne une nouvelle de destination du neoud host en fonction de la vitesse speed"


	\subsection*{Strategie 2 : FullRandom (InitialPositionStrategy, NextDestinationStrategy)}

		\subsubsection{\texttt{getInitialPosition}}
		\par La strategie pour la position initiale est de creer en une table associative a partir de tous les noeuds du reseau et grace a la fonction \texttt{Network.get(i)} ("Returns node with the given index. Note that the same node will normally have a different index in different times. le ieme dans la liste des noeuds", ce qui signifie un ajout de randomization) affecter a chaque node le resultat de la fonction Destination decrite ci-apres.

		\subsubsection{\texttt{getNextDestination}}
		\par La strategie de choix de la destination suivante consiste a affecter une nouvelle position \textt{nextX} et \textt{nexty} tel que :
	\begin{gather}
		position = (my\_random.nextDouble() * maxX, \quad my\_random.nextDouble() * maxY)
	\end{gather}


	\subsection*{Strategie 3 : InitialPositionConnectedRing (InitialPositionStrategy)}
	Le but de cette fonction est de calculer la position des points en fonction d'un centre pour les placer autour de celui-ci. Elle utilise : \texttt{centre.getNewPositionWith} qui "Calcul une nouvelle position à partir d'un module et d'un angle depuis la position courante".
	Explicitons les calcules, nous reutiliserons les variables \texttt{maxX, maxY, scope maxX/2 et maxY/2}, nous ajoutons une variable centre qui est definie par les coordonnes \texttt{maxX/2,MaxY/2}, la taille du reseau, appelee \texttt{size} et une variable rayon qui nous aidera a placer les points autour du centre.
	\begin{gather}
		Soit \quad rayon \in Entier, \\
		rayon = min(size*(scope/8), maxY / 2.5) \\
		\\
		exemple \quad : \\ 
		size = 10 \quad scope = 32 \quad maxY = 500 \\
		rayon = min(10*4, 500/2.5) \\
		rayon = min(40, 200) = 40
	\end{gather}
	Le calcule du rayon differe si les noeuds sont paires ou impaires. voici la fin du calcule s'ils sont paire :
	\begin{gather}
		Soit \quad rayon \in Entier, \\
		Soit \quad numero\_de\_node \in Entier paire, \\
		rayon = rayon - (scope/2) \\
		\\
		exemple \quad : \\ 
		rayon = 40 - (32/2) = -210
	\end{gather}
	Il faut maintenant un \texttt{delta\_angle} qui servira au calcule de la position cournte de la fonction \texttt{center.getNewPositionWith},
	\begin{gather}
		Soit \quad delta\_angle \in Entier, \\
		delta\_angle = \dfrac{2 * \pi}{size} \\ 
		\\
		exemple \quad : \\ 
		size = 10 \\
		delta\_angle = \dfrac{2 * \pi}{10} = 0.6283 \quad(approx)\\ 
	\end{gather}

	\par l'appelle a la fonction  :
	\begin{lstlisting}
		centre.getNewPositionWith(rayon, delta_angle * host.getID())
	\end{lstlisting}
	\par placera donc les noeuds de 0 a 9 ainsi :	
	\begin{figure}[H]
		\centering
		\includegraphics[width=0.5\textwidth, frame]{InitialPositionConnectedRing}
		\caption{Representation du placement InitialPotisionConnectedRing, le cercle represente le rayon (scope) et on voit bien que tous les nodes sont places autour d'un centre en (0,0). Pour se faire nous avons choisi une position initial (0,0). Cette position initiale est necessaire lors de l'appelle a la fonction \texttt{getNewPositionWith} qui fait partie de la classe Position}
		\label{fig:mesh1}
	\end{figure}



	\subsection*{Strategie 4 : InitialPositionConnectedRing (InitialPositionStrategy)}



	\subsection*{Stragerie 5 : NextDestinationConnectedOneMove (NextDestinationStrategy)}



	\subsection*{Strategie 6 : NextDestinationImmobility (NextDestinationStrategy)}



	\subsection*{Strategie 7 : NextDestinationRandomPeriodicInitial (NextDestinationStrategy)}



	\newpage
	\chapter{Exercice 2 – Implémentation d’algorithmes d’élection de Leader sur un MANET}
	\section*{Premier algorithme}

	\section{Question 1}
	\textit{Dans la section III, expliquez pour chaque hypothèse, pourquoi elle est vérifiée (ou
		peut être vérifiée) dans notre simulateur.}

	\section{Question 2}

	\section{Question 3}

	\section{Question 4}

	\section*{Deuxieme algorithme}

	\section{Question 5}
	\textit{L’algorithme utilise des horloges logiques. A quoi servent-elles ?  Pourquoi chaque nœud ne peut incrémenter uniquement sa propre horloge ?}
	\section{Question 6}
	\textit{Pourquoi le knowledge est émis dans sa totalité à la détection de l’arrivée d’un nœud dans le voisinage ?}
	\section{Question 7}
	\textit{Quel est l’intérêt de créer des edits lors de la déconnexion d’un voisin ou de la réception d’un knowledge, au lieu d’envoyer le knowledge dans son ensemble ?}
	\section{Question 8}
	\textit{Quel est le contenu d’un edit ?}
	\section{Question 9}
	\textit{Qu’implique l’adjectif reachable ligne 46 ?}
	\section{Question 10}
	\textit{Implémentez l’algorithme dans PeerSim et vérifiez qu’il fonctionne avec le moniteur graphique.}
	\section{Question 11}
	\textit{Considérons maintenant qu’il puisse y avoir des pertes de messages suite aux collisions des ondes radio (on ne vous demande pas de les implémenter).}
	\begin{itemize}
		\item \textit{Quel impact ceci aurait sur les valeurs des horloges (old\_clock et knowledge[source].clock) lors des réceptions de edit ?}
		\item \textit{Comment pourrions-nous résoudre efficacement ce problème (encore une fois , il n’est pas demandé de l’implémenter)}
	\end{itemize}

	\newpage
	\chapter{Exercice 3 – Étude expérimentale}

	\newpage
	\bibliographystyle{IEEEtran}
	\bibliography{biblio}

	\newpage
	% \phantomsection
	\addcontentsline{toc}{chapter}{\listfigurename}
	\listoffigures



	\newpage
	\chapter{Annexe}




\end{document}

