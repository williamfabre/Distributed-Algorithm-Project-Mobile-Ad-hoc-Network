\documentclass[11pt,a4paper,sans]{report}
\input{header.sty}

\begin{document}
\begin{titlepage}

	\center % Center everything on the page

	%----------------------------------------------------------------------------------------
	%	HEADING SECTIONS
	%----------------------------------------------------------------------------------------

	\textsc{\LARGE Université Pierre et Marie Curie}\\[1.5cm] % Name of your university/college
	\textsc{\Large projet MANET}\\[0.5cm] % Major heading such as course name

	%----------------------------------------------------------------------------------------
	%	TITLE SECTION
	%----------------------------------------------------------------------------------------
	\vfill
	\HRule \\[0.4cm]
	{ \huge \bfseries Compte-rendu : Projet ARA 2019–2020, Mobile Ad hoc NETworks }\\[0.4cm] 
	\HRule \\[1.5cm]
	\vfill
	%----------------------------------------------------------------------------------------
	%	AUTHOR SECTION
	%----------------------------------------------------------------------------------------

	\begin{minipage}{0.4\textwidth}
		\begin{flushleft} \large
			\emph{Auteurs:}\\
			% Ordre alphabetique sur les noms
			\textsc{Maria Popova, William Fabre} 
		\end{flushleft}
	\end{minipage}
	~
	\begin{minipage}{0.4\textwidth}
		\begin{flushright} \large
			\emph{Professeur:} \\
			Monsieur \textsc{Lejeune},\textsc{Favier}
		\end{flushright}
	\end{minipage}\\[2cm]

	%----------------------------------------------------------------------------------------
	%	DATE SECTION
	%----------------------------------------------------------------------------------------

	{\large Année 2019-2020}\\[2cm] % Date, change the \today to a set date if you want to be precise

\end{titlepage}

\newpage
\tableofcontents
\vspace*{3cm}
\begingroup\let\clearpage\relax

	\newpage
	\chapter{Introduction}
	L’élection du leader est un de problèms fondamentaux de l'algorithmique répartie. Dans les réseaux mobiles, où la topology se changes tout le temps, ce problème de l’élection devient beaucoup plus compliqué. Les buts principaux de ce projet sont d'implémenter et de comparer deux algorithmes d’élection du leader différents, ainsi qu’étudier leurs comportement dans un réseau MANET. Ensuite, comparer les performances des algorithmes, notamment le nombre de messages échangés et un taux d’instabilité, en fonction de rayon d'émission du node. 


	%multilinecomments
	\begin{comment}
		% TODO quotation work use the biblio.bib to add references.
		TODOCHANGEHEREtest1234\cite{greenwade93}
	\end{comment}


	\begin{center}
		\textsc{\large Préparation du projet et installation}
	\end{center}
	\par Pour utiliser le projet il suffit d'utiliser le script :
	\mylisting[basicstyle=\tiny,frame=rlbt,language=Bash]{../launch.sh}

	\newpage
	\chapter{Exercice 1 – Implémentation d’un MANET dans Peer-Sim}

	\section{Question 1}
	\textit{En analysant le code de la classe PositionProtocolImpl, donnez l’algorithme général de déplacement d’un nœud. Il ne vous est pas demandé de copier/coller le code dans cette question.}
	\par Le but de cet algorithme est de deplacer un noeud dans l'espace de deux dimenssions en direction d'une position choisi en fonction de la strategie de deplacement.  L'algorithme de deplacement du noeud fonctionne comme suit :
	\par Si le noeud ne bouge pas alors il est mis en mouvement. C'est a dire q'on lui affecte une vitesse \texttt{vi} aleatoire bornee par un \texttt{MinSpeed} et un \texttt{MaxSpeed}. Puis on lui choisi une desination qui est de type Position (element qui possede deux coordonnes). Il faut maintenant calculer la distance en metres entre le point de depart, qui est la position du Node et la position d'arrivee, que nous appellerons destination ; Grace a la formule suivante :
	\begin{gather}
		Soit \quad  (dest, cur) \in Position^2, \\
		distance = (dest.x - cur.x)^2 + (dest.y - cur.y)^2 
	\end{gather}
	\par C'est la distance total pour arriver a destination. Maintenant il nous faut calculer la distance totale parcourable en une unite de temps. Elle est egale a la vitesse dans la metrique du systeme, c'est a dire, la vitesse \texttt{vi} en metres par secondes qu'il faut diviser par mille pour avoir des metre par millisecondes.
	\begin{gather}
		Soit  \quad  (vi) \in Vitesse \quad (m*s^{-1}), \\
		distance\_to\_next= vi / 1000
	\end{gather}
	\par Si la distance totale est inferieur a la distance parcourable en une unite de temps il faut alors calculer une nouvelle Position intermediaire et donc un x et un y:

	\begin{gather}
		Soit  \quad  (next_x,next_y) \in long^2 \\
		Soit  \quad  (\theta_{1}, \theta_{2}) \in degree^2 \\
		next\_x =  (distance\_to\_next * \dfrac{(dest.x - cur.x)}{((dest.x - cur.x)^2 + (dest.y - cur.y)^2)}) + cur.x \\
		\Longleftrightarrow \\
		next\_x =  (distance\_to\_next * \sin{\theta_{1}}) + cur.x \\
		\\
		\\
		next\_y =  (distance\_to\_next * \dfrac{(dest.y - cur.y)}{((dest.x - cur.x)^2 + (dest.y - cur.y)^2)}) + cur.y \\
		\Longleftrightarrow \\
		next\_y =  (distance\_to\_next * \cos(\theta_{2})) + cur.x \\
	\end{gather}

	Sinon, si la distance total est egale ou inferieur a la distance parcourable en une unite de temps, alors on affete les coordonnes de la position destination a notre Node.  On vient verifier si la position a change, pour affecter une pause; Sinon on incremente le temps du simulateur d'une unite de temps.

	\section{Question 2}
	\textit{Testez le simulateur en prenant la stratégie FullRandom comme SPI et SD. Le contrôleur graphique sera déclenché toutes les unités de temps, son timeslow pourra être environ de 0.0002. Le seul protocole à renseigner pour ce contrôleur est le PositionProtocol de la simulation, les autres sont pour l’instant optionnels et sans objet.  Normalement vous devez voir graphiquement des points verts se déplacer sur l’écran.  N’oubliez pas d’amorcer les instances de PositionProtocol via un module d’initialisation. Vous répondrez à cette question en donnant le contenu de votre fichier de configuration.}
	\mylisting[basicstyle=\tiny,frame=rlbt,language=Java]{../src/ara/config} %with frame

	\newpage
	\section{Question 3}
	\textit{Codez une classe implémentant l’interface Emitter. Testez de nouveau avec le moniteur graphique et assurez-vous que les portées sont représentées (cercle en bleu).}
	\mylisting[basicstyle=\tiny,frame=rlbt,language=Java, firstline=14, lastline=124]{../src/ara/manet/communication/EmitterProtocolImpl.java}


	\section{Question 4}

	\section{Question 5}
	\par\textit{Testez votre code, et remarquez sur le moniteur graphique l’apparition d’un lien graphique lorsque deux nœuds deviennent voisins.}
	\begin{figure}[h]
		\centering
		\includegraphics[width=\textwidth, frame]{question5_links}
		\caption{Representation de l'apparition de lien lors de la simulation}
		%\label{fig:simu}
	\end{figure}


	\par Comme on peut le voir dans la figure %\ref{fig:simu}
	, il y a bien apparition de liens
	entre les différents node s'ils sont respectivement dans le scope l'un de l'autre avec le scope visible par représentation d'un cercle autour du node.

	\newpage
	\section{Question 6}
	\textit{En analysant les codes des classes gérant le positionnement des nœuds qui font appel à un tirage aléatoire, on peut remarquer qu’ils utilisent un objet Random qui leur est dédié (attribut my\_random initialisé au random de la classe PositioningConfiguration).  Quelle en est la raison ?}

	Le but de nos simulations est d'evaluer un ensemble d'algorithme avec differents types de placement, deplacements de nodes. la reproductibilite de ces simulations est importante pour des soucis de debug ou de l'analyse. Maitriser tres exactement la seed de randomization est un point cle pour avoir des algorithmes avec des placements aleatoires mais maitrises. On peut voir que la classe \texttt{PositioningConfiguration} recuperer \texttt{PAR\_SEED\_POSITIONING} depuis le fichier de configuration. De plus si d'autres classes utilisent ce même randomizer il faut que je comportement reste déterministe.


	\section{Question 7}
	\textit{Prenez connaissance des différentes stratégies et pour chacune expliquez ce qu’elle fait.}
	Pour chacune les strategies de placement de noeuds dans l'espace il existe deux types de placement : Un placement dit initial et un deplacement qui sont represente par deux fonctions :
	\texttt{getInitialPosition} et \texttt{getNextDestination}. Les strategies implementent ces fonctions si elles implementent leur interfaces : \texttt{InitialPositionStrategy} et \texttt{NextDestinationStrategy} ceci sera precise dans le titre des sections suivantes.

	\subsection*{Strategie 1 : ConnectedRandom (InitialPositionStrategy, NextDestinationStrategy)}
	\subsubsection{\texttt{getInitialPosition} et \texttt{getNextDestination}}
	\par Le schema suivant s'applique pour definir une position initial ou trouver une nouvelle position a un noeud.

	\begin{figure}[H]
		\centering
		\includegraphics[width=0.9\textwidth, frame]{StrategieConnectedRandom}
		\caption{Representation du calcule pour le placement connected Random}
		%\label{fig:strat1}
	\end{figure}


	\par Les elements de la figure %\ref{fig:strat1} TODO
	sont :
	\begin{itemize}
		\item A gauche, la grille de placement des noeuds avec \texttt{max\_X} et \texttt{max\_Y} qui sont des parametres du systeme. On peut aussi voir \texttt{max\_X / 2} et \texttt{max\_Y / 2}. Pour finir, \texttt{maxX, maxY, minX, minY} correspondent aux nouveaux min et max calcules par la fonction en additionnant ou soustrayant delta visible graphiquement. La zone hachuree correspond a l'ensemble des coordonnees possible pour une position randomizee.
		\item A droite, On peut observer le scope d'un noeud et un parametre de marge de l'algorithme Connected Random.
		\item En bas on peut observer graphiquement la taille de \textt{scope-marge}
	\end{itemize}

	La figure ci dessus %\pageref{fig:strat1}
	represente l'implementation pour les fonctions \texttt{getInitialPosition} et \texttt{getNextDestination}, il existe un argument de fonction speed qui n'est pas utilise malgre le fait que l'interface \texttt{NextDestinationStrategy} explique : "Retourne une nouvelle de destination du neoud host en fonction de la vitesse speed".

	\subsection*{Strategie 2 : FullRandom (InitialPositionStrategy, NextDestinationStrategy)}

	\subsubsection{\texttt{getInitialPosition}}
	\par La strategie pour la position initiale est de creer en une table associative a partir de tous les noeuds du reseau et grace a la fonction \texttt{Network.get(i)} ("Returns node with the given index. Note that the same node will normally have a different index in different times. le ieme dans la liste des noeuds", ce qui signifie un ajout de randomization) affecter a chaque node le resultat de la fonction Destination decrite ci-apres.

	\subsubsection{\texttt{getNextDestination}}
	\par La strategie de choix de la destination suivante consiste a affecter une nouvelle position \textt{nextX} et \textt{nexty} tel que :
	\begin{gather}
		position = (my\_random.nextDouble() * maxX, \quad my\_random.nextDouble() * maxY)
	\end{gather}


	\subsection*{Strategie 3 : InitialPositionConnectedRing (InitialPositionStrategy)}
	\subsubsection{\texttt{getInitialPosition}}
	Le but de cette fonction est de calculer la position des points en fonction d'un centre pour les placer autour de celui-ci. Elle utilise : \texttt{centre.getNewPositionWith} qui "Calcul une nouvelle position à partir d'un module et d'un angle depuis la position courante".
	Explicitons les calcules, nous reutiliserons les variables \texttt{maxX, maxY, scope maxX/2 et maxY/2}, nous ajoutons une variable centre qui est definie par les coordonnes \texttt{maxX/2,MaxY/2}, la taille du reseau, appelee \texttt{size} et une variable rayon qui nous aidera a placer les points autour du centre.
	\begin{gather}
		Soit \quad rayon \in Entier, \\
		rayon = min(size*(scope/8), maxY / 2.5) \\
		\\
		exemple \quad : \\ 
		size = 10 \quad scope = 32 \quad maxY = 500 \\
		rayon = min(10*4, 500/2.5) \\
		rayon = min(40, 200) = 40
	\end{gather}
	Le calcule du rayon differe si les noeuds sont paires ou impaires. voici la fin du calcule s'ils sont paire :
	\begin{gather}
		Soit \quad rayon \in Entier, \\
		Soit \quad numero\_de\_node \in Entier paire, \\
		rayon = rayon - (scope/2) \\
		\\
		exemple \quad : \\ 
		rayon = 40 - (32/2) = -210
	\end{gather}
	Il faut maintenant un \texttt{delta\_angle} qui servira au calcule de la position cournte de la fonction \texttt{center.getNewPositionWith},
	\begin{gather}
		Soit \quad delta\_angle \in Entier, \\
		delta\_angle = \dfrac{2 * \pi}{size} \\ 
		\\
		exemple \quad : \\ 
		size = 10 \\
		delta\_angle = \dfrac{2 * \pi}{10} = 0.6283 \quad(approx)\\ 
	\end{gather}

	\par l'appelle a la fonction  :
	\begin{lstlisting}
		centre.getNewPositionWith(rayon, delta_angle * host.getID())
	\end{lstlisting}
	\par placera donc les noeuds de 0 a 9 ainsi :
	\begin{figure}[h]
		\centering
		\includegraphics[width=0.5\textwidth, frame]{InitialPositionConnectedRing}
		\caption{Representation du placement InitialPotisionConnectedRing}
		\floatfoot{Le cercle represente le rayon (scope) et on voit bien que tous les nodes sont places autour d'un centre en (0,0). Pour se faire nous avons choisi une position initial (0,0). Cette position initiale est necessaire lors de l'appelle a la fonction \texttt{getNewPositionWith} qui fait partie de la classe Position}
		%\label{fig:strat3}
	\end{figure}



	\subsection*{Strategie 4 : InitialPositionConnectedRing (InitialPositionStrategy)}
	\subsubsection{\texttt{getInitialPosition}}
	Le but de cette strategie est de definir une position initiale pour tous les noeuds en une passe. C'est un chainage entre les noeuds vont se placer en fonction d'un voisin. Il existe un traitement specifique pour le tout premier noeud. L'algorithme redefini des bornes pour positionner le premier noeud. appelons les valeurs definies par defaut \texttt{old\_maxX} et \texttt{old\_maxY}. Cette nouvelle position est ajoutee a une \texttt{hashmap<id, Position>} qui s'appelle \texttt{initial\_position} qui est partagee par toutes les instances de cette classe.
	\begin{gather}
		Soit \quad (old\_maxX,old\_maxY) \in Entier^2 \\
		Soit \quad (minX,maxX,minY,maxY) \in Entier^4 \\
		Soit \quad p \in Position
		minX = old\_maxX / 3; \quad maxX = old\_maxX; \\
		minY = old\_maxY / 3; \quadmaxY = old\_maxY;\\
		p = ([minX, maxX], [minY, maxY]) \\
	\end{gather}
	Pour tous les autres noeuds,  ils choisissent un voisin qui possede un id egale a la taille de la hashmap \texttt{initial\_position}. ils choisissent au hasard, un angle, une distance bornee avec une verification que ces bornes sont bien definies grace a une fonction \texttt{bound}.
	Pour finir ils s'ajoutent a  la hashmap partagee.


	\subsection*{Stragerie 5 : NextDestinationConnectedOneMove (NextDestinationStrategy)}
	\subsubsection{\texttt{getNewPositionWith}}
	Le but de cette strategie est de definir une nouvelle position pour un node nomme \texttt{host} tout en gardant une seule composante connexe sur le reseau. Toute division en plusieurs composantes apres deplacement d'un noeud n'est pas retenu et le noeud reste immobile jusqu'a son prochain deplacement.
	\par Elle defini une variable qui represente le protocol du noeud \texttt{host} concerne par le deplacement appelee \texttt{pos\_proto\_host}
	\par Elle defini mais n'utilise pas un set qui associe a un \texttt{ID} de node une liste de noeuds qui est la composante connexe de ce noeud nommee \texttt{initial\_connected\_component}. Ce set est initialise par la ligne commande :
	\begin{lstlisting}[language=java]
		PositionProtocol.getConnectedComponents(PositionProtocol.getPositions(position_pid), scope);
	\end{lstlisting}
	\texttt{getConnectedComponents} : "méthode statique renvoyant l'ensemble des composantes connexes du système, renvoie une map associant un id de la composante connexe à son ensemble de noeud"
	\texttt{PositionProtocol.getPositions} : "méthodes statiques utiles pour toutes informations relative à la position des noeuds et à la topographie du système"
	\par Cette algorithme a aussi besoin du \texttt{scope} et defini un node \texttt{current\_moving} qui est le noeud precedemment mis en mouvement par l'appelle precedent de la fonction \texttt{getNewPositionWith}.
	\par \texttt{1ER PARTIE DE L'ALGO :}
	Le but est de stoper le noeud host s'il est en mouvement. Si le noeud \texttt{current\_moving} existe, alors il est stoppe et la fonction renvoie la valeur la position actuelle du noeud host.  Si le noeud ne bouge pas alors \textt{current\_moving} est remis a \texttt{null}.
	\par \texttt{2ND PARTIE DE L'ALGO :}
	Le noeud host n'est pas en mouvement et est autorise a bouger alors il choisi un voisin au hasard. un angle et une distance bornee par les bornes suivantes :
	\begin{gather}
		Soit \quad (distance\_min, distance\_max) \in ParametresDeBase \\
		min\_distance = min(scope, max(distance\_min, 0)) \\
		max\_distance = min(distance\_max, scope)
	\end{gather}

	La nouvelle position est cree et on verifie ses bornes. On recupere localement la liste desPositions des noeuds du reseau et on verifie s'il y a une division dans le reseau apres mise a jour de la position du node (un split qui serait du au deplacement du noeud sur sa nouvelle position). Si ce n'est pas le cas il devient le noeud \texttt{current\_moving} et renvoie la nouvelle position. Sinon il reste sur place. 




	\subsection*{Strategie 6 : NextDestinationImmobility (NextDestinationStrategy)}
	\subsubsection{\texttt{getNewPositionWith}}
	Cette strategie renvoie comme nouvelle position pour le node \texttt{host} la position actuelle du node host, il ne bouge pas.



	\subsection*{Strategie 7 : NextDestinationRandomPeriodicInitial (NextDestinationStrategy)}
	\subsubsection{\texttt{getNewPositionWith}}
	Cette strategie est parametre par une periode a specifier dans le fichier de configuration appelee \texttt{random\_dest\_period}. C'est une strategie possedant deux etats. Soit les noeuds sont a la position initiale, soit les noeuds appliquent la strategie FullRandom avec un placement completement aleatoire. Les noeuds sont places de maniere aleatoire pendant \texttt{random\_dest\_period} cycles de simulation. Ensuite ils passent tous en position initiale et retourne en positionnement aleatoire lorsque tous les noeuds sont passes dans l'etat initial.


	\newpage
	\chapter{Exercice 2 – Implémentation d’algorithmes d’élection de Leader sur un MANET}
	\section*{Premier algorithme}

	\begin{comment}
		an undirected graph that changes over time as nodes move. The vertices in the graph correspond to mobile nodes and an edge between a pair of nodes represents the fact that the two nodes are within each other’s transmission radii and, hence, can directly communicate with one another. The graph can become disconnected if the network is partitioned due to node movement
	\end{comment}

	\section{Question 1}
	\textit{Dans la section III, expliquez pour chaque hypothèse, pourquoi elle est vérifiée (ou peut être vérifiée) dans notre simulateur.}

	\subsection{Node Value:}
	\textit{"Each node has a value associated with it. The value of a node indicates its “desirability” as a leader of the network and can be any performance-related attribute such as the node’s battery power, computational capabilities etc."}

	l'interface ElectionProtocol est obligatoire pour implementer un protocol d'election. On peut voir y trouver une fonction avec le description suivante :
	\mylisting[basicstyle=\tiny,frame=rlbt,language=Java, firstline=17, lastline=21]{../src/ara/manet/algorithm/election/ElectionProtocol.java}


	\subsection{Unique and Ordered Node IDs:}
	\textit{"All nodes have unique identifiers. They are used to identify participants during the election process. Node IDs are used to break ties among nodes which have the same value."}

	Soit un node host, host.getID() a pour definition :
	\begin{lstlisting}[language=java]
		Returns the unique ID of the node. It is guaranteed that the ID is unique during the entire simulation, that is, there will be no different Node objects with the same ID in the system during one invocation of the JVM. Preferably nodes should implement hashCode() based on this ID.
	\end{lstlisting}

	\subsection{Links:}
	\textit{"Links are bidirectional and FIFO, i.e. messages are delivered in order over a link between two neighbors."}
	Les liens ne sont pas complètement FIFO. En effet par test nous avons pu voir que deux messages devant arriver au même temps ont un ordre non défini. Ce problème n'a pas été réglé car lors de notre tentative de rajouter un protocol FIFO (provenannt des tp d'introduction à la matière ARA) il y avait des problèmes de délivrance de messages. Cette couche n'est donc plus visibile dans notre projet et reste une amélioration possible.

	\subsection{Node Behavior:}
	\textit{"Node mobility may result in arbitrary topology changes including network partitioning and merging. Furthermore, nodes can crash arbitrarily at any time and can come back up again at any time."}
	Cette propriéte correspond aux differentes strategies de noeuds que nous avons decrite. Par exemple la strategie FullRandom peut autoriser des partitionnement ou des fusions. Pour finir les crash ne sont pas modélisés dans notre système.

	\subsection{Node-to-Node Communications:}
	\textit{"A message delivery is guaranteed only when the sender and the receiver remain connected (not partitioned) for the entire duration of message transfer."}

	Dans la classe EmitterProtocolImpl on peut voir la fonction recvMsg :
	\mylisting[basicstyle=\tiny,frame=rlbt,language=Java, firstline=44, lastline=66]{../src/ara/manet/communication/EmitterProtocolImpl.java}

	On peut voir dans cette fonction qu'on verifie bien ligne 19 que le la distance entre les noeuds est bien inferieur ou egale a la taille du scope qui permet la communication entre deux noeuds.

	\subsection{Buffer Size:}
	\textit{"Each node has a sufficiently large receive buffer to avoid buffer overflow at any point in its lifetime."}
	La taille de la mémoire en chaque noeud du graph est virtuellement infini et la seule borne est la mémoire de la machine qui simule cette taille infinie.

	\section{Question 2}
	Ceci correspond à la classe : VKT04Statique.java

	\section{Question 3}
	Ceci correspond à la classe : VKT04NextGeneration.java

	\section{Question 4}
	Ceci correspond à la classe : VKT04NextGeneration.java

	\section*{Deuxieme algorithme}

	\section{Question 5}
	\textit{L’algorithme utilise des horloges logiques. A quoi servent-elles ?  Pourquoi chaque nœud ne peut incrémenter uniquement sa propre horloge ?}
	Ad hoc est un système réparti, alors on ne possède pas de temps globale. Voilà pourquoi on utilise des horloges logiques pour avoir des relations de causalité entre événements. Dans un algorithme donné, des horloges logiques permettent de construire un vue globale du système pour chaque noeud. A l’arrivé des messages contenants des informations sur les voisins on vérifie si on possede la derniere vision de l’état des voisins. Si ce n’est pas le cas, on le modifie. De plus, un algorithm donné se base sur le nombre importants de broadcasts parallels et transits, donc il faut bien définir des changements parallèles et la causalité. Voilà pourquoi on utilise des vecteurs, qui garde l’état de chaque noeud.

	Une horloge locale d’un noeud permet de définir des événements locaux liés avec un état de ce noeud, notamment la connexion et la déconnexion de voisin dans un contexte de cet algorithme. Supposons que chaque node possède qu’une horloge logique associée à sa connaissance du système à chaque instant. Dans ce cas là, à l’arrivé d’une nouvelle information à propos des voisins, on ne soit pas capable de définir si cette information est toujours actuelle, ou on possède déjà un vue du systèmes le plus récent. Par exemple, un noeude se connecte à une composante connexe, et ce noeud a une horloge plus grande que les autres, alors il remplacera les tables actuels de noeuds. Un autre exemple :  si un noeud se connecte à un groupe de noeuds et sa propre horloge est le plus petit, le groupe apprendra jamais qu’il a un nouveau voisin.


	\section{Question 6}
	\textit{Pourquoi le knowledge est émis dans sa totalité à la détection de l’arrivée d’un nœud dans le voisinage ?}
	Le knowledge est émis dans sa totalité à un nouveau voisin pour le faire connaître les membres de la composante connexe auquelle il viens de connecter. Cela lui permettra à déduire qui est le leader de la composante.


	\section{Question 7}
	\textit{Quel est l’intérêt de créer des edits lors de la déconnexion d’un voisin ou de la réception d’un knowledge, au lieu d’envoyer le knowledge dans son ensemble ?}
	Envoie du message de type Edit lors de la déconnection d’un noeud ou de la réception d’un knowledge permet de diminuer la taille du message. De plus cela permet d’éviter des comparaisons inutiles de knowledges tables, car des noeuds d’une composante connexes possèdent déjà la même information grâce à l'échange de knowledge pendant la connexion.



	\section{Question 8}
	\textit{Quel est le contenu d’un edit ?}
	Message de type Edit <Source[], Added[], Removed[], old_clock[], new_clock[]> contient 5 tableaux : 
	\begin{itemize}
		\item l’ensemble des identifiants des noeuds “source” qui ont eu des changements
		\item les identifiant des noeuds à ajouter pour chaque noeud de l’ensemble  “source”
		\item les identifiant des noeuds à supprimer pour chaque noeud de l’ensemble  “source”
		\item la dernière valeur de l’horloge logique annoncé par un noeud de “source” au système avant les modifications
		\item la nouvelle valeur de l’horloge qui correspond à une horloge locale du noeud de l’ensemble  “source” après les modifications
	\end{itemize}

	\section{Question 9}
	\textit{Qu’implique l’adjectif reachable ligne 46 ?}
	Le mot “reachable” dans un contexte de l’appel d'élection du leader implique qu’on doit consulter les voisins de nos voisins etc., en parcourant knowledge table, pour analyser tous les membres de la composante connexe.


	\section{Question 10}
	\textit{Implémentez l’algorithme dans PeerSim et vérifiez qu’il fonctionne avec le moniteur graphique.}
	\section{Question 11}
	\textit{Considérons maintenant qu’il puisse y avoir des pertes de messages suite aux collisions des ondes radio (on ne vous demande pas de les implémenter).}
	\begin{itemize}
		\item \textit{Quel impact ceci aurait sur les valeurs des horloges (old\_clock et knowledge[source].clock) lors des réceptions de edit ?}
		\item \textit{Comment pourrions-nous résoudre efficacement ce problème (encore une fois , il n’est pas demandé de l’implémenter)}
	\end{itemize}

	\newpage
	\chapter{Exercice 3 – Étude expérimentale}
	\begin{center}
		\textsc{\large Étude du MANET}
	\end{center}
	\section{Question 1}
	\textit{Codez un contrôleur PeerSim qui logue au moment de son déclenchement (à l’instant
		t) :}
	\par Ceci correspond à la classe Echantillon.java

	\textit{Tracez deux courbes qui prennent en abscisse la portée et en ordonnée :}

	\begin{figure}[H]
		\centering
		\begin{tabular}{lllll}
			SCOPE   & AVG       & VARIAN    & ECARTYPE    &  \\
				&           &           &             &  \\
			10  & 74,0938   & 1,0443357 & 1,021927444 &  \\
			15  & 72,8932   & 2,132048  & 1,460153417 &  \\
			20  & 71,199265 & 3,0677357 & 1,751495275 &  \\
			25  & 69,19755  & 7,444554  & 2,728471    &  \\
			30  & 66,60122  & 10,856718 & 3,294953414 &  \\
			35  & 63,730675 & 11,454374 & 3,384431119 &  \\
			40  & 60,927666 & 10,705435 & 3,271916105 &  \\
			45  & 57,67347  & 11,19165  & 3,345392354 &  \\
			50  & 54,301525 & 12,085005 & 3,476349378 &  \\
			55  & 50,753845 & 13,506486 & 3,675117141 &  \\
			60  & 47,21383  & 14,683654 & 3,831925626 &  \\
			65  & 43,482803 & 17,876562 & 4,228068353 &  \\
			70  & 39,615482 & 20,303667 & 4,505959054 &  \\
			75  & 36,261147 & 21,719477 & 4,660415969 &  \\
			80  & 32,61825  & 21,509182 & 4,637799263 &  \\
			85  & 29,399742 & 19,794657 & 4,449118677 &  \\
			90  & 26,5655   & 17,533619 & 4,187316444 &  \\
			95  & 23,73342  & 14,779007 & 3,844347409 &  \\
			100 & 21,28886  & 11,391274 & 3,375096147 &  \\
			105 & 19,064852 & 9,370501  & 3,061127407 &  \\
			110 & 16,983139 & 9,280732  & 3,046429385 &  \\
			115 & 14,848684 & 8,8740425 & 2,978933114 &  \\
			120 & 12,860526 & 7,9126935 & 2,812951031 &  \\
			125 & 11,394495 & 6,898599  & 2,626518418 &  \\
			130 & 9,967378  & 5,4308906 & 2,330427128 &  \\
			135 & 8,921147  & 3,4729683 & 1,863590164 &  \\
			140 & 7,5822945 & 2,509846  & 1,584249349 & 
		\end{tabular}
		\caption{Jeu de données récupérées pour tracer les courbes. On peut notamment y voir le scope qui croit de 5 en 5, AVG représente la connexité moyenne pour un scope donné et la variance ainsi que l'écart type pour ce scope donné.}
	\end{figure}

	\subsection{la connexité moyenne à t end}
	\par\textit{Testez votre code, et remarquez sur le moniteur graphique l’apparition d’un lien graphique lorsque deux nœuds deviennent voisins.}
	\begin{figure}[H]
		\centering
		\includegraphics[width=0.8\textwidth, frame]{connexite}
		\caption{Cette Courbe rerésente avec un pas de 5 sur l'axe des x la connexité moyenne. Celle ci représente le nombre moyen de composantes connexe pour un scope donné. Attention nous avons laisse 0 comme valeur minimale pour le nombre de composante connexe moyen mais c'est bien sur une valeur non atteignable dans notre simulation qui comporte 75 noeuds.}
	\end{figure}


	\subsection{la variance (ici l'écart type) de la connexité moyenne à t end pour l’autre}
	\begin{figure}[H]
		\centering
		\includegraphics[width=0.8\textwidth, frame]{ecarttype}
		\caption{On peut ici voir ici l'écart-type, qui signifie "à quel point cette connexité moyenne va varier pendant l'éxécution, l'écart type est compris entre 1 et 5 ce qui est faible pour notre jeu de donné variant entre un peu moins de 10 et à peu près 80 }
		%\label{fig:simu}
	\end{figure}



	\section{Question 3}
	\textit{Pourquoi est-ce pertinent de choisir la stratégie FullRandom comme stratégie de po- sitionnement pour cette expérience ?  Interprétez, commentez et expliquez vos résultats.}
	Il est intéressant d'avoir la stratégie FullRandom d'après nos courbes. Cette stratégie nous montre qu'elle est un bon random à travers les deux courbes.
	
	En effet, on observe, dans la première courbe on peut voir qu'elle n'est pas abrupte, les changements se font lents et sa forme en S semble signifier qu'elle est bornée (une sorte de sigmoïde à pente très douce). Lorsque le scope est petit les noeuds ont tendance à être seuls, il y a donc plus de composantes connexes, puis lorsque le scope augmente les noeuds se connectent et le nombre de composantes connexes augmente, cette courbe est donc très certainement borné par le nombre de noeuds égale au maximum de composantes connexes et 1 seule composante connexe regroupant tous les noeuds.
	On observe dans la seconde courbe qui malgré le fait que nos noeuds soient en grand nombre (75), le nombre de composantes connexes a tendance à varier peu. En effet, l'écart-type est faible et possède un maximum en taille de scope de 75 où y a beaucoup de connexions/déconnexions de noeuds. On peut aussi voir un sursaut un peu fort entre 25 et 25 où il semble manquer des points dans la courbe. Une amélioration aurait pu être un échantillonage plus fort pour augmenter la précision, mais cela ne change rien à la remarque générale, l'écart type est faible.
	On peut en déduire avec un écart type faible et une pente douce pour la connexité moyenne que la stratégie random est un bon random, en effet il a des résultats cohérents si le scope augmente le nombre de composantes connexes doit augmenter de manière régulière et ne pas avoir des comportements inattendu sinon nous ne pourrions pas faire des mesures à partir de cette stratégie.

	\newpage
	\begin{center}
		\textsc{\large Étude comparative des algorithmes d’élection de leader}
	\end{center}
	\section{Question 5}
	\textit{Codez un protocole décorateur d’Emitter qui s’intercalera au-dessus de l’emitter réel et en dessous du protocole d’élection.}
	Ceci est trouvable dans la classe WrapperEmitter qui utilise le DP Wrapper.

	\section{Question 6}
	\textit{Implémentez un mécanisme permettant de calculer le taux d’instabilité.}

	Voici le code du calcule du taux d'instabilité :

	\mylisting[basicstyle=\tiny,frame=rlbt,language=Java, firstline=221, lastline=253253]{../src/ara/manet/Echantillon.java}

	\section{Question 7}
	\textit{Faites une étude comparative des deux algorithmes selon les deux métriques pour plusieurs valeurs de connexité. Vous ne vous intéresserez qu’aux valeurs des deux métriques à l’instant t end de l’expérience. Des courbes commentées et justifiées sont attendues.}
	% TODO



	%\newpage
	%\bibliographystyle{IEEEtran}
	%\bibliography{biblio}

	%\newpage
	% \phantomsection
	%\addcontentsline{toc}{chapter}{\listfigurename}
	%\listoffigures



	\newpage
	\chapter{Annexe}




\end{document}

